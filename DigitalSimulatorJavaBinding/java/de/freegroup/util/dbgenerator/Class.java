package de.freegroup.util.dbgenerator;

import java.util.*;
import java.io.*;
import java.lang.*;
/**
 * Title:        ShortiDatabase2Java
 * Description:
 * Copyright:    Copyright (c) 2001
 * Company:      short-i
 * @author Andreas Herz
 * @version 1.0
 */

class Class
{
    String  name;
    String  packageName;
    HashMap properties;
    ArrayList  reverseRelations;
    String  primaryKey ="";
    boolean hasAutoincrementProperty=false;

    static TreeSet nonquoted;
    static TreeSet needToSQL;

    static final String DBCLASS_PREFIX ="_db";
    static final String CLASS_PREFIX   ="";

    /**
     *
     */
    public Class(String _name, String _packageName)
    {
        name        = _name;
        packageName = _packageName;
        properties  = new HashMap();
        reverseRelations = new ArrayList();
    }

    /**
     *
     */
    public void addProperty(String propName, String type, boolean isIdentity)
    {
        if(isIdentity)
            hasAutoincrementProperty = true;

        properties.put(propName, new PropertyClass(propName, type, isIdentity));
    }

    public void addReverseRelation(String reverseClass, String reverseProperty, boolean isUnique)
    {
        System.out.println("add reverse relation:"+name+"."+reverseProperty+"-> "+reverseClass+"["+isUnique+"]" );
        reverseRelations.add(new ReversePropertyClass(reverseClass, reverseProperty, isUnique));
    }

    /**
     *
     */
    public void setForeignKey(String propName, String foreignKeyClass, String foreignKeyProperty)
    {
        PropertyClass prop;
        prop = (PropertyClass) properties.get(propName);
        prop.setForeignKey(foreignKeyClass, foreignKeyProperty);
    }


    /**
     *
     */
    public void setUnique(String propName)
    {
        PropertyClass prop;
        prop = (PropertyClass) properties.get(propName);
        prop.setUnique(true);
    }

    /**
     *
     */
    public boolean isUnique(String propName)
    {
        PropertyClass prop;
        prop = (PropertyClass) properties.get(propName);
        return prop.getUnique();
    }

    /**
     *
     */
    public void setPrimaryKey(String propName)
    {
        PropertyClass prop;

        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            prop.setPrimaryKey(false);
        }

        prop = (PropertyClass) properties.get(propName);
        prop.setPrimaryKey(true);
        primaryKey = propName;
    }

    /**
     * returns the code of the generated database class
     *
     */
    public String getDBCode()
    {
        StringBuffer classString = new StringBuffer(1024);
        PropertyClass prop;

        classString.append(generateHeader());
        classString.append("\n");
        classString.append("class "+DBCLASS_PREFIX  + this.name + " extends dbObject \n");
        classString.append("{\n");
        classString.append(generateProperties());
        classString.append("\n");
        classString.append("\n");
        classString.append(generateDestroy());
        classString.append(generatePropertyMethods());
        classString.append(generateForeignPropertiesMethods());
        classString.append(generateGetReverseRelations());
        classString.append(generateFindByMethods());
        classString.append(generateCommit());
        classString.append(generateGetAll());
        classString.append(generateCreateInstance());
        classString.append(generateNewInstance());
        classString.append(generateDestroyInstance());
        classString.append(generateDestroyAll());
        classString.append(generateToString());
        classString.append(generateStatic());
        classString.append("}\n");

        return classString.toString();
    }

    /**
     * returns the code of the generated class
     *
     */
    public String getCode()
    {
        StringBuffer classString = new StringBuffer(1024);
        PropertyClass prop;

        classString.append(generateHeader());
        classString.append("\n");
        classString.append("public class "+CLASS_PREFIX + name + " extends "+DBCLASS_PREFIX +name+"\n");
        classString.append("{\n");
        classString.append("}\n");
        return classString.toString();
    }

    /**
     *
     */
    String generateHeader()
    {
        StringBuffer classString = new StringBuffer(1024);
        Date date = new Date(System.currentTimeMillis());

        classString.append("package " + this.packageName + ";\n");
        classString.append("\n");
        classString.append("/**\n");
        classString.append(" * Class generated by automatic ClassGenerator\n");
        classString.append(" * Date: " +  date.toString() + "\n");
        classString.append(" */\n");

        classString.append("import de.freegroup.digitalsimulator.db.*;\n");
        classString.append("import java.util.ArrayList;\n");
        classString.append("import java.util.Iterator;\n");
        classString.append("import java.sql.*;\n");
        classString.append("import de.freegroup.digitalsimulator.Trace;\n");

        return classString.toString();
    }

    /**
     * generates all properties from the class
     *
     */
    String generateProperties()
    {
        String spaces = "         ";
        StringBuffer classString = new StringBuffer(1024);
        PropertyClass prop;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        classString.append("\n");
//        classString.append("\tstatic TraceDispatcher  trace = TraceFactory.getTraceDispatcher();\n");
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            // generate the formating space delimiter
            //
            String delim = spaces.substring(0,spaces.length()-prop.getType().length());
            classString.append("\t" + prop.getType() + delim+" " + prop.getName() + ";");
            if(prop.getPrimaryKey())
            {
                classString.append("\t// Key");
            }
            if((prop.getForeignKeyClass()!=null) && (prop.getForeignKeyClass().length()>0) &&
               (prop.getForeignKeyProperty()!=null) && (prop.getForeignKeyProperty().length()>0))
            {
                classString.append("\t// Foreign Key pointing to Table [" + prop.getForeignKeyClass() +
                                   "], Field [" + prop.getForeignKeyProperty() + "]");
            }
            classString.append("\n");
        }

        return classString.toString();
    }

    /**
     *
     */
    String generatePropertyMethods()
    {
        StringBuffer classString = new StringBuffer(1024);
        PropertyClass prop;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        classString.append("\n");
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());

            if(!prop.getForeignKey())
            {
                // generate the GET-method
                //
                String getName = "get" +firstUpper(prop.getName())+ "()";
                String setName = "set" +firstUpper(prop.getName())+ "("+ prop.getType() + " _" + prop.getName() + ", boolean _autoCommit)";

                // generate the GET-method
                //
                classString.append("\t/**\n");
                classString.append("\t * Method:      " + getName               + "\n");
                classString.append("\t * Description: " + prop.getDescription() + "\n");
                classString.append("\t * Returns:     " + prop.getType()        + "\n");
                classString.append("\t */\n");
                classString.append("\tpublic " + prop.getType() + " " + getName + "\n");
                classString.append("\t{\n");
                classString.append("\t\treturn " + prop.getName() + ";\n");
                classString.append("\t}\n");
                classString.append("\n");

                // generate the SET-method
                //
                if(!prop.getPrimaryKey() && !prop.getIsAutoIncrement())
                {
                    classString.append("\t/**\n");
                    classString.append("\t * Method:      " + setName               + "\n");
                    classString.append("\t * Description: " + prop.getDescription() + "\n");
                    classString.append("\t * Returns:     void\n");
                    classString.append("\t */\n");

                    classString.append("\tpublic void " + setName + "\n");
                    classString.append("\t{\n");
                    classString.append("\t\t" + prop.getName() + "=_"+ prop.getName()+";\n");
                    classString.append("\t\tif(_autoCommit)\n");
                    classString.append("\t\t{\n");
                    classString.append("\t\t\tcommit();\n");
                    classString.append("\t\t}\n");
                    classString.append("\t}\n");
                    classString.append("\n");
                }
            }

        }
        return classString.toString();
    }

    /**
     *
     */
    String generateStaticPropertyMethods()
    {
        StringBuffer classString = new StringBuffer(1024);
        PropertyClass prop      = null;
        PropertyClass primeProp = null;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        // determine the primary key property
        //
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            if(prop.getPrimaryKey())
            {
                primeProp = prop;
            }
        }


        // no primary key define -> no static update functions possible
        //
        if(primeProp==null)
            return "";

        // generate the static update methods
        //
        classString.append("\n");
        it = propSet.iterator();
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());

            String setName = "set" +firstUpper(prop.getName())+ "("+ primeProp.getType() + " _key, "+ prop.getType() + " _" + prop.getName()+" )";

            // generate the SET-method
            //
            if(!prop.getPrimaryKey())
            {
                classString.append("\t/**\n");
                classString.append("\t * Method:      " + setName               + "\n");
                classString.append("\t * Description: " + prop.getDescription() + "\n");
                classString.append("\t * Returns:     void\n");
                classString.append("\t */\n");

                classString.append("\tpublic void " + setName + "\n");
                classString.append("\t{\n");
                classString.append("\t}\n");
                classString.append("\n");
            }
        }
        return classString.toString();
    }


    /**
     *
     */
    String generateForeignPropertiesMethods()
    {
        StringBuffer classString = new StringBuffer(1024);
        PropertyClass prop;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        it = propSet.iterator();
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            String getMethodName  = "get"+firstUpper(prop.getName());
            String setMethodName  = "set"+firstUpper(prop.getName());

            if(prop.getForeignKey())
            {
                String foreignPropName = ("" + prop.getForeignKeyProperty().charAt(0)).toUpperCase()
                                          + prop.getForeignKeyProperty().substring(1);
                getMethodName = remove_id(getMethodName);
                setMethodName = remove_id(setMethodName);

                // the get-Method
                //
                classString.append("\t/**\n");
                classString.append("\t * Method:      " + getMethodName  + "()\n");
                classString.append("\t * Description: " + prop.getDescription() + "\n");
                classString.append("\t * Returns:     " + prop.getForeignKeyClass() + "\n");
                classString.append("\t */\n");

                classString.append("\tpublic " + prop.getForeignKeyClass() + " " + getMethodName + "()\n");
                classString.append("\t{\n");
                classString.append("\t\treturn "+CLASS_PREFIX  + prop.getForeignKeyClass() +
                                   ".findBy" + foreignPropName + "(" +
                                   prop.getName() + ");\n");
                classString.append("\t}\n");
                classString.append("\n");

                // The set.Method
                //
                classString.append("\t/**\n");
                classString.append("\t * Method:      " + setMethodName  + "()\n");
                classString.append("\t * Description: " + prop.getDescription() + "\n");
                classString.append("\t * Returns:     void\n");
                classString.append("\t */\n");

                classString.append("\tpublic void " + setMethodName + "("+prop.getForeignKeyClass()+" _foreigner, boolean _autocommit)\n");
                classString.append("\t{\n");
                classString.append("\t\t"+prop.getName()+"= _foreigner.getId();\n");
                classString.append("\t\tif (_autocommit == true)\n");
                classString.append("\t\t\tcommit();\n");
                classString.append("\t}\n");
                classString.append("\n");
            }
        }
        return classString.toString();
    }

    /**
     *
     */
    String generateGetReverseRelations()
    {
        StringBuffer classString = new StringBuffer(1024);

        Iterator iter = reverseRelations.iterator();
        while (iter.hasNext())
        {

            ReversePropertyClass prop =(ReversePropertyClass) iter.next();

            // es sind keine mehrfachreferenzen von einer tabele auf
            // eine andere tabele generierbar. ....namenskonflikt bei
            // bei der namenskonvention
            Iterator dupIter = reverseRelations.iterator();
            int duplCount =0;
            while(dupIter.hasNext() )
            {
                ReversePropertyClass dupProp=(ReversePropertyClass) dupIter.next();
                if(dupProp.getReverseClass().equals(prop.getReverseClass()))
                    duplCount ++;
            }
            if(duplCount >1)
            {
                // create no funktion
                System.out.println("WARNING: generate no duplicate function (no naming convention in this case)");
                continue;
            }


            if(prop.getUnique()==false)
            {
                String methodName           = "get"+prop.getReverseClass();
                String methodSignature      = "";
                String methodTypeDescriptor = "ArrayList<"+prop.getReverseClass()+">";
                String reverseMethodName    = "findBy"+firstUpper(prop.getReverseProperty());

                reverseMethodName = remove_id(reverseMethodName);

                // fit the signature name
                //
                int idIndex;
                if((methodName.toUpperCase().endsWith("Y")))
                {
                    idIndex=methodName.toUpperCase().lastIndexOf("Y");
                    methodName = methodName.substring(0, idIndex)+"ies";
                }
                else if((methodName.toUpperCase().endsWith("S")))
                {
                    idIndex=methodName.toUpperCase().lastIndexOf("S");
                    methodName = methodName.substring(0, idIndex)+"es";
                }
                else
                {
                    methodName = methodName+"s";
                }
                methodSignature = methodName+"()";

                classString.append("\t/**\n");
                classString.append("\t *  Method:      " + methodSignature       + "\n");
                classString.append("\t *  Description:                              \n");
                classString.append("\t *  Returns:     " + methodTypeDescriptor  + "\n");
                classString.append("\t */\n");
                classString.append("\tpublic ArrayList "+methodSignature+"\n");
                classString.append("\t{\n");
                classString.append("\t\treturn "+DBCLASS_PREFIX+prop.getReverseClass()+"."+reverseMethodName+"(this);\n");
                classString.append("\t}\n");
                classString.append("\n");
                classString.append("\n");
            }
            else
            {
                String methodName           = "get"+prop.getReverseClass()+"()";
                String methodTypeDescriptor = prop.getReverseClass();
                String reverseMethodName    = "findBy"+firstUpper(prop.getReverseProperty());
                String methodSignature      = methodTypeDescriptor+" "+methodName;

                reverseMethodName = remove_id(reverseMethodName);

                classString.append("\t/**\n");
                classString.append("\t *  Method:      " + methodSignature       + "\n");
                classString.append("\t *  Description:                              \n");
                classString.append("\t *  Returns:     " + methodTypeDescriptor  + "\n");
                classString.append("\t */\n");
                classString.append("\tpublic "+methodSignature+"\n");
                classString.append("\t{\n");
                classString.append("\t\treturn "+DBCLASS_PREFIX+prop.getReverseClass()+"."+reverseMethodName+"(this);\n");
                classString.append("\t}\n");
                classString.append("\n");
                classString.append("\n");
            }
        }
        return classString.toString();
    }

    /**
     *
     */
    String generateFindByMethods()
    {
        StringBuffer classString = new StringBuffer(1024);
        PropertyClass prop;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        it = propSet.iterator();
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            String methodName  = "findBy"+firstUpper(prop.getName());
            String paramName = "_"+prop.getName();
            String methodType  = "";
            String methodTypeDescriptor = "";

            methodName =remove_id(methodName);
            paramName = remove_id(paramName);

            if(prop.getPrimaryKey() || prop.getUnique())
            {
                methodType           = CLASS_PREFIX +name;
                methodTypeDescriptor = CLASS_PREFIX +name;
            }
            else
            {
                methodType           = "ArrayList";
                methodTypeDescriptor = "ArrayList<" +CLASS_PREFIX + name + ">";
            }
            String methodSignature;

            if(prop.getForeignKey())
                methodSignature = methodName  + "(" +DBCLASS_PREFIX+ prop.getForeignKeyClass()  + " "+ paramName + ")";
            else
                methodSignature = methodName  + "(" + prop.getType()  + " "+ paramName + ")";


            classString.append("\t/**\n");
            classString.append("\t *  Method:      " + methodSignature       + "\n");
            classString.append("\t *  Description: " + prop.getDescription() + "\n");
            classString.append("\t *  Returns:     " + methodTypeDescriptor  + "\n");
            classString.append("\t */\n");

            classString.append("\tpublic static " + methodType + " " +methodSignature+"\n");
            classString.append("\t{\n");
            if(prop.getPrimaryKey() || prop.getUnique())
                classString.append("\t\t"+CLASS_PREFIX +name+" result = null;\n");
            else
                classString.append("\t\tArrayList result = new ArrayList();\n");
            classString.append(generateSQLHeader(methodName));

            String sqlQuery;
//            String paramAppendix="";
            if(prop.getForeignKey())
                paramName = "(("+paramName+"==null)?\"\":"+paramName+".getId())";

            if(nonquoted.contains(prop.getType()))
            {
                if(needToSQL.contains(prop.getType()))
                    sqlQuery = "\""+generateSQL()+" WHERE "+prop.getName()+"=\"+toSQL("+paramName+")";
                else
                    sqlQuery = "\""+generateSQL()+" WHERE "+prop.getName()+"=\"+"+paramName;
            }
            else
            {
                if(needToSQL.contains(prop.getType()))
                    sqlQuery = "\""+generateSQL()+" WHERE "+prop.getName()+"='\"+toSQL("+paramName+")+\"'\"";
                else
                    sqlQuery = "\""+generateSQL()+" WHERE "+prop.getName()+"='\"+"+paramName+"+\"'\"";
            }


            classString.append("\t\t\t\tResultSet s = stmt.executeQuery( "+sqlQuery+");\n");

            // iterate over all return objects and create the corresponding
            // class instance and insert them in the result ArrayList
            //
            if(prop.getPrimaryKey() || prop.getUnique())
            {
                PropertyClass prop2;
                Set      propSet2 = properties.keySet();
                Iterator it2      = propSet2.iterator();
                int      index    = 1;
                classString.append("\t\t\t\tif(s.next())\n");
                classString.append("\t\t\t\t{\n");
                classString.append("\t\t\t\t\tresult = new "+CLASS_PREFIX+name+"();\n");
                while(it2.hasNext())
                {
                    prop2 = (PropertyClass) properties.get((String) it2.next());
                    classString.append("\t\t\t\t\tresult."+prop2.getName()+"= s.get"+firstUpper(prop2.getType())+"("+index+");\n");
                    index++;
                }
            }
            else
            {
                PropertyClass prop2;
                Set      propSet2 = properties.keySet();
                Iterator it2      = propSet2.iterator();
                int      index    = 1;
                classString.append("\t\t\t\twhile(s.next())\n");
                classString.append("\t\t\t\t{\n");
                classString.append("\t\t\t\t\t"+CLASS_PREFIX+name+" newObject = new "+CLASS_PREFIX+name+"();\n");
                while(it2.hasNext())
                {
                    prop2 = (PropertyClass) properties.get((String) it2.next());
                    classString.append("\t\t\t\t\tnewObject."+prop2.getName()+"=s.get"+firstUpper(prop2.getType())+"("+index+");\n");
                    index++;
                }
                classString.append("\t\t\t\t\tresult.add(newObject);\n");
            }
            classString.append("\t\t\t\t}\n");

            classString.append(generateSQLFooter());
            classString.append("\t\treturn result;\n");
            classString.append("\t}\n");
            classString.append("\n");
        }

        return classString.toString();
    }

    /**
     *
     */
    String generateGetAll()
    {
        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * returns ArrayList<"+CLASS_PREFIX+name+">\n");
        methodString.append("\t */\n");
        methodString.append("\tpublic static ArrayList getAll()\n");
        methodString.append("\t{\n");
        methodString.append("\t\tArrayList result = new ArrayList();\n");
        methodString.append(generateSQLHeader("getAll"));

        methodString.append("\t\t\t\tResultSet s = stmt.executeQuery( \""+generateSQL()+"\");\n");

        // iterate over all return objects and create the corresponding
        // class instance and insert them in the result ArrayList
        //
        methodString.append("\t\t\t\twhile(s.next())\n");
        methodString.append("\t\t\t\t{\n");
        PropertyClass prop;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        methodString.append("\t\t\t\t\t"+CLASS_PREFIX +name+" newObject = new "+CLASS_PREFIX +name+"();\n");
        int index = 1;
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            methodString.append("\t\t\t\t\tnewObject."+prop.getName()+"=s.get"+firstUpper(prop.getType())+"("+index+");\n");
            index++;
        }
        methodString.append("\t\t\t\t\tresult.add(newObject);\n");
        methodString.append("\t\t\t\t}\n");

        methodString.append(generateSQLFooter());
        methodString.append("\t\treturn result;\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateCommit()
    {
        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * returns boolean\n");
        methodString.append("\t */\n");
        methodString.append("\tpublic boolean commit()\n");
        methodString.append("\t{\n");
        methodString.append(generateSQLHeader("commit"));

        methodString.append("\t\t\t\tstmt.executeUpdate( \""+generateUpdateSQL()+");\n");


        methodString.append(generateSQLFooter());
        methodString.append("\t\treturn true;\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateCreateInstance()
    {
        // generate the function signature
        //
        PropertyClass prop;
        Set      propSet = properties.keySet();
        Iterator it      = propSet.iterator();
        String   funcName = "createInstance( ";
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            if(!prop.getPrimaryKey() && !prop.getIsAutoIncrement())
            {
                if(prop.getForeignKey())
                    funcName = funcName + DBCLASS_PREFIX+ prop.getForeignKeyClass()  + " _"+  remove_id(prop.getName()) + ", ";
                else
                    funcName = funcName + prop.getType()  + "  _"+  prop.getName() + ", ";
            }
        }
        // remove the trailing ", " from the function declaration
        //
        if(funcName.endsWith(", "))
            funcName = funcName.substring(0,funcName.length()-2);

        funcName = funcName+" )";

        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * create a new object in the database\n");
        methodString.append("\t */\n");
        methodString.append("\tstatic public "+name+" "+funcName+"\n");
        methodString.append("\t{\n");
        methodString.append("\t\t"+name+" result = null;\n");
        methodString.append(generateSQLHeader("createInstance"));
        methodString.append("\t\t\t\tString nextGUID = new java.rmi.server.UID().toString();\n");
        methodString.append("\t\t\t\tstmt.executeUpdate( "+generateCreateSQL()+");\n");

        if(hasAutoincrementProperty==true)
        {
            methodString.append("\t\t\t\t// the object has an autoincrement property. This property is\n");
            methodString.append("\t\t\t\t// generated by the database. An select to the database is required\n");
            methodString.append("\t\t\t\t// to retrieve this id\n");
            methodString.append("\t\t\t\tresult = findById(nextGUID);\n");
        }
        else
        {
            methodString.append("\t\t\t\tresult = new "+name+"();\n");
            it = propSet.iterator();
            while(it.hasNext())
            {
                prop = (PropertyClass) properties.get((String) it.next());
                if(!prop.getIsAutoIncrement())
                {
                    if(!prop.getPrimaryKey())
                    {
                        if(prop.getForeignKey())
                            methodString.append("\t\t\t\tresult."+prop.getName()+"= (_"+remove_id(prop.getName())+"==null)?\"\":_"+remove_id(prop.getName())+".getId();\n");
                        else
                            methodString.append("\t\t\t\tresult."+prop.getName()+"= _"+prop.getName()+";\n");
                    }
                    else
                    {
                        methodString.append("\t\t\t\tresult."+prop.getName()+"= nextGUID;\n");
                    }
                }
            }
        }
        methodString.append(generateSQLFooter());
        methodString.append("\t\treturn result;\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateNewInstance()
    {
        // generate the function signature
        //
        PropertyClass prop;
        boolean  enforceRetrieveObject =false;
        Set      propSet = properties.keySet();
        Iterator it      = propSet.iterator();
        String   funcName = "newInstance( ";
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            if(!prop.getPrimaryKey() && !prop.getIsAutoIncrement())
            {
                if(prop.getForeignKey())
                    funcName = funcName + DBCLASS_PREFIX+ prop.getForeignKeyClass()  + " _"+  remove_id(prop.getName()) + ", ";
                else
                    funcName = funcName + prop.getType()  + "  _"+  prop.getName() + ", ";
            }
        }
        // remove the trailing ", " from the function declaration
        //
        if(funcName.endsWith(", "))
            funcName = funcName.substring(0,funcName.length()-2);

        funcName = funcName+" )";

        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * create a new object in the database\n");
        methodString.append("\t */\n");
        methodString.append("\tstatic public void "+funcName+"\n");
        methodString.append("\t{\n");
        methodString.append(generateSQLHeader("newInstance"));
        methodString.append("\t\t\t\tString nextGUID = new java.rmi.server.UID().toString();\n");
        methodString.append("\t\t\t\tstmt.executeUpdate( "+generateCreateSQL()+");\n");

        methodString.append(generateSQLFooter());
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateDestroy()
    {
        // generate the function signature
        //
        PropertyClass prop;
        Set      propSet = properties.keySet();
        Iterator it      = propSet.iterator();
        String   funcName = "destroy()";

        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * destroy a object in the database\n");
        methodString.append("\t */\n");
        methodString.append("\tpublic boolean "+funcName+"\n");
        methodString.append("\t{\n");
        methodString.append("\t\tboolean result = false;\n");
        methodString.append("\t\tString    _key   = id;\n");
        methodString.append(generateSQLHeader("destroyInstance"));

        methodString.append("\t\t\t\t\tstmt.executeUpdate( "+generateDestroySQL()+");\n");
        methodString.append("\t\t\t\t\tresult = true;\n");
        methodString.append("\t\t\t\t\tid     = null;\n");

        methodString.append(generateSQLFooter());
        methodString.append("\t\treturn result;\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateDestroyInstance()
    {
        // generate the function signature
        //
        PropertyClass prop;
        Set      propSet = properties.keySet();
        Iterator it      = propSet.iterator();
        String   funcName = "destroyInstance( String  _key)";

        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * destroy a object in the database\n");
        methodString.append("\t */\n");
        methodString.append("\tstatic public boolean "+funcName+"\n");
        methodString.append("\t{\n");
        methodString.append("\t\tboolean result = false;\n");
        methodString.append(generateSQLHeader("destroyInstance"));

        methodString.append("\t\t\t\t\tstmt.executeUpdate( "+generateDestroySQL()+");\n");
        methodString.append("\t\t\t\t\tresult = true;\n");

        methodString.append(generateSQLFooter());
        methodString.append("\t\treturn result;\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateDestroyAll()
    {
        String   funcName = "destroy( )";

        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * destroy ALL objects in the database\n");
        methodString.append("\t */\n");
        methodString.append("\tstatic public boolean destroyAll()\n");
        methodString.append("\t{\n");
        methodString.append("\t\tboolean result = false;\n");
        methodString.append(generateSQLHeader("destroyAll"));

        methodString.append("\t\t\t\t\tstmt.executeUpdate(\"DELETE from "+name+"\" );\n");
        methodString.append("\t\t\t\t\tresult = true;\n");

        methodString.append(generateSQLFooter());
        methodString.append("\t\treturn result;\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateStatic()
    {
        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t * init the class\n");
        methodString.append("\t */\n");
        methodString.append("\tstatic\n");
        methodString.append("\t{\n");
//        methodString.append("\t\ttry\n");
//        methodString.append("\t\t{\n");
//        methodString.append("\t\t\tDatabaseMetaData dMeta = ConnectionManager.getValid().getMetaData ();\n");
//        methodString.append("\t\t\tResultSet result;\n");
//
//        Set propSet = properties.keySet();
//        Iterator it = propSet.iterator();
//        while(it.hasNext())
//        {
//            PropertyClass prop = (PropertyClass) properties.get((String) it.next());
//            methodString.append("\t\t\tresult=dMeta.getColumns(null,null,\""+name+"\",\""+prop.getName()+"\");\n");
//            methodString.append("\t\t\tif(!result.next())\n");
//            methodString.append("\t\t\t{\n");
//            methodString.append("\t\t\t\tSystem.out.println(\"ERROR: installed DB-schema not compatible to java classes\");\n");
//            methodString.append("\t\t\t\tSystem.out.println(\"       Attribute '"+prop.getName()+"' in table '"+name+"' missing\");\n");
//            methodString.append("\t\t\t}\n");
//            methodString.append("\t\t\tresult.close();\n");
//        }
//
//        methodString.append("\t\t}\n");
//        methodString.append("\t\tcatch (Exception ex)\n");
//        methodString.append("\t\t{\n");
//        methodString.append("\t\t}\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");
        return methodString.toString();
    }

    /**
     *
     */
    String generateToString()
    {
        StringBuffer methodString = new StringBuffer(1024);
        methodString.append("\t/**\n");
        methodString.append("\t */\n");
        methodString.append("\tpublic String toString()\n");
        methodString.append("\t{\n");
        PropertyClass prop;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        methodString.append("\t\tStringBuffer result = new StringBuffer(1024);\n");
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            methodString.append("\t\tresult.append("+prop.getName()+");\n");
            if(it.hasNext())
                methodString.append("\t\tresult.append(\"|\");\n");
        }
        methodString.append("\t\treturn result.toString();\n");
        methodString.append("\t}\n");
        methodString.append("\n");
        methodString.append("\n");

        return methodString.toString();
    }

    /**
     *
     */
    String generateSQL()
    {
        StringBuffer sqlString = new StringBuffer(1024);
        PropertyClass prop;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        sqlString.append("SELECT ");
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            sqlString.append(prop.getName());
            if(it.hasNext())
                sqlString.append(", ");
        }

        sqlString.append(" FROM "+name);
        return sqlString.toString();
    }

    /**
     *
     */
    String generateUpdateSQL()
    {
        StringBuffer sqlString = new StringBuffer(1024);
        PropertyClass prop;
        boolean       first    = true;
        PropertyClass primeProp= null;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        sqlString.append("UPDATE "+name+" set ");
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            if(!prop.getIsAutoIncrement())
            {
                if(prop.getPrimaryKey()/* || prop.getUnique()*/)
                {
                    primeProp = prop;
                }
                else
                {
                    if(nonquoted.contains(prop.getType()))
                    {
                        if(needToSQL.contains(prop.getType()))
                            sqlString.append(prop.getName() +"= \"+toSQL("+prop.getName()+")+\", ");
                        else
                            sqlString.append(prop.getName() +"= \"+"+prop.getName()+"+\", ");
                    }
                    else
                    {
                        if(needToSQL.contains(prop.getType()))
                            sqlString.append(prop.getName() +"= '\"+toSQL("+prop.getName()+")+\"', ");
                        else
                            sqlString.append(prop.getName() +"= '\"+"+prop.getName()+"+\"', ");
                    }
                }
            }
        }
        // remove the last ", " from the sql string
        //
        sqlString.setLength(sqlString.length()-2);

        if(primeProp != null)
        {
            sqlString.append(" WHERE "+primeProp.getName()+"='\"+"+primeProp.getName()+"+\"'\"");
        }
        return sqlString.toString();
    }

    /**
     *
     */
    String generateDestroySQL()
    {
        StringBuffer sqlString = new StringBuffer(1024);
        PropertyClass prop;
        sqlString.append("\"DELETE FROM "+name+" WHERE "+primaryKey+"='\"+_key+\"'\"");

        return sqlString.toString();
    }


    /**
     *
     */
    String generateCreateSQL()
    {
        StringBuffer sqlString = new StringBuffer(1024);
        PropertyClass prop;
        boolean       first    = true;
        PropertyClass primeProp= null;
        Set propSet = properties.keySet();
        Iterator it = propSet.iterator();

        sqlString.append("\"INSERT INTO "+name+" ( ");
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            // ignore the autoincrement propertie
            if( !prop.getIsAutoIncrement())
            {
                sqlString.append(prop.getName());
                if(it.hasNext())
                    sqlString.append(", ");
            }
        }
        sqlString.append(") VALUES (");
        it = propSet.iterator();
        while(it.hasNext())
        {
            prop = (PropertyClass) properties.get((String) it.next());
            if( !prop.getIsAutoIncrement())
            {
                if(prop.getPrimaryKey())
                {
                    sqlString.append("'\"+nextGUID+\"'");
                }
                else
                {
                    if(prop.getForeignKey())
                    {
                        if(nonquoted.contains(prop.getType()))
                            sqlString.append(" \"+((_"+remove_id(prop.getName())+"==null)?\"\":_"+remove_id(prop.getName())+".getId())+\"");
                        else
                            sqlString.append(" '\"+((_"+remove_id(prop.getName())+"==null)?\"\":_"+remove_id(prop.getName())+".getId())+\"'");
                    }
                    else
                    {
                        if(nonquoted.contains(prop.getType()))
                        {
                            if(needToSQL.contains(prop.getType()))
                                sqlString.append("\"+toSQL(_"+prop.getName()+")+\"");
                            else
                                sqlString.append("\"+_"+prop.getName()+"+\"");
                        }
                        else
                        {
                            if(needToSQL.contains(prop.getType()))
                                sqlString.append(" '\"+toSQL(_"+remove_id(prop.getName())+")+\"'");
                            else
                                sqlString.append(" '\"+_"+remove_id(prop.getName())+"+\"'");
                        }
                    }
                }
                if(it.hasNext())
                    sqlString.append(", ");
            }
        }
        sqlString.append(")\"");

        return sqlString.toString();
    }
    /**
     *
     */
    String generateSQLHeader(String identifier)
    {
        StringBuffer header = new StringBuffer(1024);

        header.append("\t\tSaveStatement  stmt;\n");
        header.append("\n");
        header.append("\t\ttry\n\t\t{\n");
        header.append("\t\t\tstmt  = ConnectionManager.getValid().createStatement(\""+DBCLASS_PREFIX+name+"."+identifier+"\");\n");;
        header.append("\t\t\ttry\n");
        header.append("\t\t\t{\n");

        return header.toString();
    }

    /**
     *
     */
    String generateSQLFooter()
    {
        StringBuffer footer = new StringBuffer(1024);

        footer.append("\t\t\t}\n");

        //
        footer.append("\t\t\tcatch(Exception exc)\n");
        footer.append("\t\t\t{\n");
        footer.append("\t\t\t\tTrace.error(exc);\n");
        footer.append("\t\t\t}\n");
        footer.append("\t\t\tstmt.close();\n");
        footer.append("\t\t\n");
        footer.append("\t\t}\n");
        footer.append("\t\tcatch (Exception ex)\n");
        footer.append("\t\t{\n");
        footer.append("\t\t\tTrace.error(ex);\n");
        footer.append("\t\t}\n");

        return footer.toString();
    }

    String remove_id(String text)
    {
        if(text.toUpperCase().endsWith("_ID"))
        {
            int index = text.toUpperCase().lastIndexOf("_ID");
            if(index >= 1)
            {
                text = text.substring(0, index);
            }
        }
        return text;
    }

    String firstUpper(String prop)
    {
       return new String(new String(""+prop.charAt(0)).toUpperCase()  + prop.substring(1));
    }

    public void writeDBCode(String path) throws IOException
    {
        String fullPath = path;

        fullPath.replace('/', '\\');
        if(!fullPath.endsWith("\\"))
        {
            fullPath += "\\";
        }
        fullPath += packageName.replace('.', '\\');

        File dir = new File(fullPath);
        if (!dir.exists())
        {
            dir.mkdirs();
        }

        fullPath += "\\";
        fullPath += DBCLASS_PREFIX;
        fullPath += this.name;
        fullPath += ".java";

        System.out.println("creating file: "+fullPath);
        File file = new File(fullPath);
        file.delete();
        FileWriter writer = new FileWriter(file);
        writer.write(this.getDBCode());
        writer.flush();
        writer.close();
    }

    public void writeCode(String path) throws IOException
    {
        String fullPath = path;

        fullPath.replace('/', '\\');
        if(!fullPath.endsWith("\\"))
        {
            fullPath += "\\";
        }
        fullPath += packageName.replace('.', '\\');

        File dir = new File(fullPath);
        dir.getPath();
        if (!dir.exists())
        {
            dir.mkdirs();
        }

        fullPath += "\\";
        fullPath += CLASS_PREFIX;
        fullPath += this.name;
        fullPath += ".java";

        File file = new File(fullPath);
        if(!file.exists())
        {
            System.out.println("creating file: "+fullPath);
            FileWriter writer = new FileWriter(file);
            writer.write(this.getCode());
            writer.flush();
            writer.close();
        }
    }

    static
    {
        nonquoted = new TreeSet();
        nonquoted.add("int");
        nonquoted.add("long");
        nonquoted.add("double");
        nonquoted.add("float");
        nonquoted.add("boolean");

        needToSQL = new TreeSet();
        needToSQL.add("String");
        needToSQL.add("Date");
        needToSQL.add("boolean");
    }
}